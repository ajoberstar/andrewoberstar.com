<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Andrew Oberstar: Adventurs in Scala/Lift Part 1</title>

    
<meta name="keywords" content="erlang,scala,clojure,programming languages,political,prolog,technical,haskell,io,php,gradle,ruby,netflix prize,raspberry pi,7 Languages in 7 Weeks">

<meta name="description" content="After completing 7 Languages in 7 Weeks, I decided to start working on a project to get my feet wet in Scala. For the past couple weeks I&#39;ve been reading through Programming in Scala, which is seemingly the definitive Scala book and is written by the language author.I&#39;ve really enjoyed a lot of Scala features so far:">



    <link rel="shortcut icon" href="images/favicon.png">
    <link rel="alternate" type="application/atom+xml" title="Posts" href="/feed.xml">

    <link href="/css/main.css" rel="stylesheet" type="text/css" />
    <link href="/css/atom-one-dark.css" rel="stylesheet" type="text/css" />
</head>

<body>
    <header id="main-header">
        <a id="brand" href="/">Andrew Oberstar</a>
        <nav>
            <li ><a href="/">Home</a></li>
            <li ><a href="/archives/">Archives</a></li>
            
            <li >
                <a href="/pages/about/">About</a>
            </li>
            
            <li><a href="/feed.xml">RSS</a></li>
        </nav>
    </header>
    <main>
        
<article>
    <header>
        <h1>Adventurs in Scala/Lift Part 1</h1>
        <h2>April 1, 2012</h2>
    </header>
    
    <p>After completing 7 Languages in 7 Weeks, I decided to start working on a project to get my feet wet in Scala. For the past couple weeks I've been reading through <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601">Programming in Scala</a>, which is seemingly the definitive Scala book and is written by the language author.</p><p>I've really enjoyed a lot of Scala features so far:</p><ul><li><p>Type inference - One of the advantages to dynamic languages is that you don't have to specify types. Usually it's so obvious what type the value should be that it's just a waste of keystrokes to specify the type yourself. Scala gives you the same benefit but with static types, so everything is still enforced by the compiler.</p><p>In Java:</p><pre><code class="java">Map map = new HashMap(); //verbose...
</code></pre><p>In Groovy:</p><pre><code class="groovy">def map = [:] //concise, but no type safety
</code></pre><p>In Scala:</p><pre><code class="scala">var map = Map[String, String]() //concise, with type safety
</code></pre></li><li><p>Traits - Traits are insanely flexible compared to being stuck with abstract classes and interfaces in Java. Being able to mix in an arbitrary number of traits to add new behavior is so much nicer than being forced into a hierarchical structure all of the time. One example I have found useful is a simple <code>Logging</code> trait to provide an instance value named <code>logger</code>.</p><pre><code class="scala">trait Logging {
  private val logger = LoggerFactory.getLogger(getClass)
}

class LogActor extends Actor with Logging {
  def act() {
    loop {
      react {
        case msg =&gt; logger.info(msg)
      }
    }
  }
}
</code></pre></li><li><p><code>if</code> structures that return values - Scala's <code>if</code> statement (and <code>for</code> expressions) can return values, which can reduce a little bit of boilerplate (and also replace the odd looking ternary operator from Java).</p><p>In Java:</p><pre><code class="java">//the if statement
int testing1;
if (somethingBoolean) {
  testing1 = "Hey that was true!";
} else {
  testing1 = "Darn, that was false.";
}


//or the ternary
int testing2 = somethingBoolean ? "Hey that was true!" : "Darn, that was false.";
</code></pre><p>In Scala:</p><pre><code class="scala">//consistently use if structure for if-like things
val testing = if (somethingBoolean) "Hey, that was true!" else "Darn, that was false."

//even more useful with implicit return
def method() = {
  if (somethingBoolean) {
     //...
    testing
  } else {
    //...
    otherTesting
  }
}
</code></pre></li><li><p><code>for</code> expressions - If I had learned about Scala after Erlang, I might have caught on to this at the time, but for expressions in Scala are very similar to list comprehensions in Erlang (I would even argue more powerful).</p><pre><code class="scala">val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

for (x &lt;- list; x &lt;= 4) yield x * 2
//returns List(2, 4, 6, 8)
</code></pre></li><li><p>Implicit return value - In Scala you don't need to explicitly return anything. The final expression calculated is what is returned. It actually seems to be considered bad style to use the <code>return</code> keyword. Groovy has this same feature, and I never really liked it (except in closures). It seemed confusing that there wasn't a return statement. However, with a staticly typed language like Scala, I'm seeing the light. Having the compiler tell you you are returning the wrong type of variable is a lot nicer than not catching it until runtime.</p></li><li><p><code>Option</code> type (i.e. Death to nulls!) - In Java, you have to worry about the dreaded <code>NullPointerException</code> (NPE) since <code>null</code> is the general approach to saying that a variable has no value. Since there's no way of telling whether a variable might be null or not, you should really be doing null checks all over the place. Yuck...</p><p>In Scala, however, the idiomatic approach is to use the <code>Option[T]</code> type. This says that the variable may or may not actually have a value. It's value will either by <code>Some(value: T)</code> or <code>None</code>. The <code>Option</code> class has a bunch of nice methods to help you deal with these results:</p><pre><code class="scala">def checkValues(map: Map[String, List[Int]]) {
  //calling get on a map returns an Option[V] (V being the type of the values in the map)
  val potato = map.get("potato")

  //can handle with pattern matching
  potato match {
    case Some(list) =&gt; list.map(_ * 2).foreach(println) //ooooo... type safety
    case None =&gt; println("potato was not set")
  }

  //can provide a default value
  potato getOrElse Nil //Nil is a shortcut for an empty list

  //can use collection operations or for expressions
  potato.map(_.map(_ * 2)) getOrElse Nil
}
</code></pre><p>Scala does still have <code>null</code> for Java interoperability, but its use is highly discouraged. If you can still get NPEs, then what's the benefit, you ask?  Using <code>Option</code> gives compile-time enforcement that the developer needs to be aware there might not be a value for this object. In Java, you have to rely on the developer reading the Javadoc and then remembering it when they go to use the method.</p></li></ul><p>There are other things I'm having trouble grasping:</p><ul><li><p>Immutability - I'm so used to the approach of encapsulating mutable state in an object, that it puzzles me to try to write a program without (or with significantly less) mutable state. Scala lets you use mutable state, but they do nudge you towards immutability. With mutable state you can pass the object to someone and know that no matter when they decide to use it, they'll have the up to date version. Granted if you passed it to another thread you have to be worried about concurrency issues. Using actors to encapsulate some of the major mutable state has been my approach so far, which seems to be helping.</p></li><li><p>Import statements - Scala has much more powerful (shoot yourself in the foot powerful) import statements. There are a bunch of different flavors:</p><pre><code class="scala">//normal import one type import
import java.net.URI //OK, makes sense

//everything in the package
import actors._  //considered bad form in Java, but OK

//import a few specific types
import xml.{Node, NodeSeq} //hmm, interesting...

//rename types
import collections.mutable.{Map =&gt; MutableMap} //whoa

//relative imports
import java._  //ok, why?
import io.File  // stop it
import util._   //really, this is just crazy

//absolute imports, if you're scared
import _root._.java.net.URL
</code></pre><p>The concepts behind these imports aren't confusing and the syntax is straightforward. My problem is that in Java wildcard imports (<code>import java.util.*</code>) are considered evil because you aren't completely sure which types you are using from which packages. It makes it a lot harder for someone new to your code to come in and understand what each of the types you use correspond to.</p><p>General practice in Scala is to use the wildcard and relative imports. Obviously you need to be careful with this because importing everything willy-nilly is just going to cause issues. There are benefits to this for importing type aliases, case classes, and implicit functions, but it's a big change.</p></li><li><p>IDE support - I'm an Eclipse guy. While Scala does have an Eclipse plugin, it's a little lacking. I understand that it's a newer language and it's going to take a while for it to catch up but there are some annoyances:</p><ul><li>Compiler errors don't display if you hover of the snippet underlined in red. You need to go to the side of screen and hover over the red X. Time drains away, seconds at a time.</li><li>Compiler errors are sometimes wrong or missing. Some compiler errors won't go away but work just fine when I compile with <code>scalac</code>. There are also things that don't fail in Eclipse that do in <code>scalac</code>. However, all in all, something is better than nothing, and considering how slow Scala compilation is, something is a good start.</li><li>Side note: One huge benefit of the IDE is that hovering over a method/variable/expression will tell you what it's qualified type is. That's a huge benefit with relative imports.</li></ul></li></ul><p>Well, that's enough for one sitting. I just started playing with Lift a couple days ago, so next post will probably about that.</p><p>As a final note: Get Up With It by Miles Davis. The End.</p>
    <footer>
        
        <div>
            <strong>Tags:</strong>
            
            <a href="/tags/scala/">scala</a>
            
            <a href="/tags/programming%20languages/">programming languages</a>
            
            <a href="/tags/technical/">technical</a>
            
        </div>
        
    </footer>
</article>

<nav>
    
    <a href="/posts/2012-09-14-if-this-then-that/">&laquo; If This Then That</a>
    
    
    <a class="right" href="/posts/2012-03-20-65-languages-in-12-days/">6.5 Languages in 12 Days &raquo;</a>
    
</nav>



    </main>
    <section id="side">
        <header>
            <h1>Tags</h1>
        </header>
        <nav>
            
            <li><a href="/tags/erlang/">erlang</a></li>
            
            <li><a href="/tags/scala/">scala</a></li>
            
            <li><a href="/tags/clojure/">clojure</a></li>
            
            <li><a href="/tags/programming%20languages/">programming languages</a></li>
            
            <li><a href="/tags/political/">political</a></li>
            
            <li><a href="/tags/prolog/">prolog</a></li>
            
            <li><a href="/tags/technical/">technical</a></li>
            
            <li><a href="/tags/haskell/">haskell</a></li>
            
            <li><a href="/tags/io/">io</a></li>
            
            <li><a href="/tags/php/">php</a></li>
            
            <li><a href="/tags/gradle/">gradle</a></li>
            
            <li><a href="/tags/ruby/">ruby</a></li>
            
            <li><a href="/tags/netflix%20prize/">netflix prize</a></li>
            
            <li><a href="/tags/raspberry%20pi/">raspberry pi</a></li>
            
            <li><a href="/tags/7%20Languages%20in%207%20Weeks/">7 Languages in 7 Weeks</a></li>
            
        </nav>
    </section>
    <footer id="main-footer">

        <p>Copyright &copy; 2020 Andrew Oberstar</p>
        <p>Powered by <a href="http://cryogenweb.org">Cryogen</a></p>
    </footer>

    <script src="/js/highlight.pack.js" type="application/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>

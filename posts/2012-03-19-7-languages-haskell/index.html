<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Andrew Oberstar: 7 Languages: Haskell</title>

    
<meta name="keywords" content="erlang,scala,clojure,programming languages,political,prolog,technical,haskell,io,php,gradle,ruby,netflix prize,raspberry pi,7 Languages in 7 Weeks">

<meta name="description" content="The final language of 7 Languages in 7 Weeks was Haskell, the only pure functional language in the book. This is the only chapter where I completely gave up on most of the exercises. More on that later...Haskell as a functional language does a lot of the things I&#39;ve seen in half the languages in the book. It has a list comprehension syntax almost identical to Erlang&#39;s, the common list manipulation functions like map, filter, and foldl, as well as pattern matching. Here&#39;s one example of a Haskell function:">



    <link rel="shortcut icon" href="images/favicon.png">
    <link rel="alternate" type="application/atom+xml" title="Posts" href="/feed.xml">

    <script src="/js/highlight.pack.js" type="application/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link href="/css/main.css" rel="stylesheet" type="text/css" />
    <link href="/css/solarized-dark.css" rel="stylesheet" type="text/css" />
</head>

<body>
    <header id="main-header">
        <a id="brand" href="/">Andrew Oberstar</a>
        <nav>
            <li ><a href="/">Home</a></li>
            <li ><a href="/archives/">Archives</a></li>
            
            <li >
                <a href="/pages/about/">About</a>
            </li>
            
            <li><a href="/feed.xml">RSS</a></li>
        </nav>
    </header>
    <main>
        
<section>
    <article class="post">
    <header class="post-header">
        <h1 class="">7 Languages: Haskell</h1>
        <h2 class="">March 19, 2012</h2>
    </header>
    
    <p>The final language of 7 Languages in 7 Weeks was <a href="http://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>, the only pure functional language in the book. This is the only chapter where I completely gave up on most of the exercises. More on that later...</p><p>Haskell as a functional language does a lot of the things I've seen in half the languages in the book. It has a list comprehension syntax almost identical to Erlang's, the common list manipulation functions like map, filter, and foldl, as well as pattern matching. Here's one example of a Haskell function:</p><pre><code class="haskell">allEven [] = []
allEven (h:t) = if even h then h:allEven t else allEven t
</code></pre><p>One of the biggest differences with Haskell compared to the other functional languages in the book is its strong, static type system. Like Scala, a lot of the types are inferred from the context. The author really hyped it up, so I thought it would be pretty intuitive. Once I dug into the second set of exercises, however, I was baffled. I tried making a function for removing an item from a list:</p><pre><code class="haskell">listRemove :: [Integer] -&gt; Integer -&gt; [Integer]
listRemove list x = foldl (\elem result -&gt; if x == elem then result else elem:result) [] list
</code></pre><p>Seemed like it should work to me. However when I compiled it, I got this:</p><pre><code>Couldn't match expected type `[Integer]' with actual type `Integer'
In the first argument of `listRemove', namely `min'
In the first argument of `sort', namely `(listRemove min list)'
In the second argument of `(:)', namely
  `(sort (listRemove min list))'
Failed, modules loaded: none.
</code></pre><p>While, at first glance, that appears to be a well described error, I can't for the life of me figure out why elem is being treated as an <code>[Integer]</code> rather than an <code>Integer</code>... And that right there is where I stopped doing the exercises.</p><p>Onle last feature of Haskell that I'll mention is that you can only declare functions with one argument. You can essentially create multi-argument functions, but they're actually "curried" to form the end result.</p><pre><code class="haskell">-- function with two parameters (kind of)
product x y = x * y

-- calling product 3 4 is equivalent to
(product 3) 4
</code></pre><p>This happens because the function "product" doesn't take two arguments. The type declaration for this would be:</p><pre><code class="haskell">double :: Integer -&gt; Integer -&gt; Integer
</code></pre><p>Which means product is a function that takes one <code>Integer</code> but returns a function that takes one more <code>Integer</code> which then returns an <code>Integer</code>. Pretty interesting concept.</p><p>There was another chapter on declaring types and monads which went almost completely over my head. It didn't help that I was already frustrated with Haskell and didn't really care how it worked anymore.</p><p>Haskell seems like it would teach me a lot about functional programming, but I don't have any intention of looking at it anytime soon. I'm sure it would be a lot easier to understand with a book tailored towards teaching the language rather than just getting a taste of what it has to offer.</p><p>I've got one more post coming to wrap up the 7 Languages book.</p>
    <footer>
        
        <div class="post-tags">
            <strong>Tags:</strong>
            
            <a href="/tags/programming%20languages/">programming languages</a>
            
            <a href="/tags/technical/">technical</a>
            
            <a href="/tags/haskell/">haskell</a>
            
            <a href="/tags/7%20Languages%20in%207%20Weeks/">7 Languages in 7 Weeks</a>
            
        </div>
        
    </footer>
</article>

    <nav>
        
        <a href="/posts/2012-03-20-65-languages-in-12-days/">&laquo; 6.5 Languages in 12 Days</a>
        
        
        <a class="right" href="/posts/2012-03-18-7-languages-erlang/">7 Languages: Erlang &raquo;</a>
        
    </nav>

    
</section>

    </main>
    <footer id="main-footer">
        <nav>
            
            <li><a href="/tags/erlang/">erlang</a></li>
            
            <li><a href="/tags/scala/">scala</a></li>
            
            <li><a href="/tags/clojure/">clojure</a></li>
            
            <li><a href="/tags/programming%20languages/">programming languages</a></li>
            
            <li><a href="/tags/political/">political</a></li>
            
            <li><a href="/tags/prolog/">prolog</a></li>
            
            <li><a href="/tags/technical/">technical</a></li>
            
            <li><a href="/tags/haskell/">haskell</a></li>
            
            <li><a href="/tags/io/">io</a></li>
            
            <li><a href="/tags/php/">php</a></li>
            
            <li><a href="/tags/gradle/">gradle</a></li>
            
            <li><a href="/tags/ruby/">ruby</a></li>
            
            <li><a href="/tags/netflix%20prize/">netflix prize</a></li>
            
            <li><a href="/tags/raspberry%20pi/">raspberry pi</a></li>
            
            <li><a href="/tags/7%20Languages%20in%207%20Weeks/">7 Languages in 7 Weeks</a></li>
            
        </nav>
        <p>Copyright &copy; 2020 Andrew Oberstar</p>
        <p>Powered by <a href="http://cryogenweb.org">Cryogen</a></p>
    </footer>
</body>

</html>

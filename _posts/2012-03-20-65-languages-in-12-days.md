---
layout: post
title: "6.5 Languages in 12 Days"
category: technical
tags:
    - programming languages
    - 7 Languages in 7 Weeks
---
I'm all done with the [7 Languages in 7 Weeks](http://pragprog.com/book/btlang/seven-languages-in-seven-weeks) book. Overall, I was very happy with it and recommend it to anyone looking to broaden their programming horizons.

This book had a very different style from other programming books I've read. Rather than explain everything I needed to understand the language (and the exercises), the author cut narrow but deep slices through the language to pick out some interesting concepts. With a book trying to show me 7 programming languages, there's nowhere near enough room to explain everything. The big benefit of that is I got to do some non-trivial examples very quickly. But since I didn't have a firm foundation in each language, I very easily tripped myself up.

The concept is supposed ot be that you spend a week on each language. Each language is divided into 3 days, since the author doesn't expect you to spend all of your time on this. But most of the days were pretty short. The 3rd day generally took a few hours of work, but it still didn't amount to much. It also seems like there was an expectation that you would read the day's chapter and then look up more information online. I did look things up while doing the exercises, but it's hard to just browse the internet for language resources when you don't really have something to work on. The end result was that I kind of rushed through the chapters and probably didn't let as much of the language absorb as I could have.

I was very glad to get these introductions to some very different languages. I think I found a few languages that I really want to use some more. The languages that I'm not very interested in gave me some new perspectives on problems that I'll appreciate even without diving deeper into the languages.

The languages that I would actually use:

- Scala seems like a good transitional language to get into functional programming. It also deals with a lot of the problems with Java:  a more expressive and flexible type system (including inferred types), support for closures, mixins, tuples, actors, and more. This was the language that was the most similar to Java, so it should be the easiest for me to get into.
- Clojure was a lot of fun to program in. The prefix notation was an interesting change of pace. This was the functional language that I found the easiest to pick up.
- Ruby has a lot of similarities to Groovy, which, besides Java, is the language I am most familiar with. It seems like it would be a very productive way to write applications. I think I would definitely need to look into Rails to get further into it.

The languages I probably won't touch again:

- Io's prototype system started to make sense to me after the exercises. I think a lot of the lessons I learned will apply to JavaScript, which I don't have much knowledge of. However, the language seems very niche and I don't think it applies that well to general usage.
- Prolog was weird. I can see how it would be really useful for logic problems, but I don't think it's something I'll find a use for. You have to think in a very different way to write programs in Prolog.
- Erlang was interesting. It had similar syntax to Prolog but was a more normal programming language. However, a lot of basic stuff was really odd to write in Erlang, and it just wasn't much fun.
- Haskell was something I had expected to like. I don't know if it was just the way it was presented in the book, but that language went way over my head. The type system didn't make much sense to me. Given how many of the exercises I skipped this is the language I only feel I got half of the benefit.

 Even if you don't buy this book, I do recommend looking into languages different than the ony you spend most of your time with. Seeing that different perspective can really help a lot even in your home language.
